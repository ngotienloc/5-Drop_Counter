/* Ð?nh nghia d?a ch? thanh ghi cho STM32F103C6 */
#define PERIPH_BASE         0x40000000
#define APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)
#define AHBPERIPH_BASE      (PERIPH_BASE + 0x20000)

// RCC (Reset and Clock Control)
#define RCC_BASE            (AHBPERIPH_BASE + 0x1000)
#define RCC_APB2ENR         (*(volatile unsigned long *)(RCC_BASE + 0x18))
#define RCC_CFGR            (*(volatile unsigned long *)(RCC_BASE + 0x04))

// GPIOA
#define GPIOA_BASE          (APB2PERIPH_BASE + 0x0800)
#define GPIOA_CRL           (*(volatile unsigned long *)(GPIOA_BASE + 0x00))
#define GPIOA_BSRR          (*(volatile unsigned long *)(GPIOA_BASE + 0x10))

// ADC1
#define ADC1_BASE           (APB2PERIPH_BASE + 0x2400)
#define ADC1_SR             (*(volatile unsigned long *)(ADC1_BASE + 0x00))
#define ADC1_CR2            (*(volatile unsigned long *)(ADC1_BASE + 0x08))
#define ADC1_SMPR2          (*(volatile unsigned long *)(ADC1_BASE + 0x0C))
#define ADC1_SQR3           (*(volatile unsigned long *)(ADC1_BASE + 0x30))
#define ADC1_DR             (*(volatile unsigned long *)(ADC1_BASE + 0x4C))

/* Ð?nh nghia các bit c?n thi?t */
#define RCC_APB2ENR_IOPAEN  (1 << 2)  // B?t clock cho GPIOA
#define RCC_APB2ENR_ADC1EN  (1 << 9)  // B?t clock cho ADC1
#define RCC_CFGR_ADCPRE_2   (1 << 14) // ADCPRE = PCLK2/2

#define ADC_CR2_ADON        (1 << 0)  // B?t ADC
#define ADC_CR2_RSTCAL      (1 << 3)  // Reset calibration
#define ADC_CR2_CAL         (1 << 2)  // B?t calibration
#define ADC_CR2_EXTSEL      (0x7 << 17) // Ch?n SWSTART
#define ADC_CR2_EXTTRIG     (1 << 20)   // B?t trigger ph?n m?m
#define ADC_CR2_SWSTART     (1 << 22)   // Kích ho?t chuy?n d?i
#define ADC_SR_EOC          (1 << 1)    // K?t thúc chuy?n d?i

#define GPIO_BSRR_BS1       (1 << 1)    // PA1 = 1
#define GPIO_BSRR_BR1       (1 << 17)   // PA1 = 0
#define GPIO_BSRR_BS2       (1 << 2)    // PA2 = 1
#define GPIO_BSRR_BR2       (1 << 18)   // PA2 = 0

/* H?ng s? cho chuong trình */
#define VREF            3300  // Vref c?a ADC = 3,3V (mV)
#define ADC_RESOLUTION  4096  // 12-bit ADC
#define MV_PER_C        10    // 10 mV/°C t? LM35
#define VOLTAGE_RATIO   1.5   // T? l? chia di?n áp (do th?c t? d? di?u ch?nh)
#define TEMP_LOW        3500  // 35,0°C (don v? 0,1°C)
#define TEMP_HIGH       3700  // 37,0°C (don v? 0,1°C)

void GPIO_Init(void);
void ADC_Init(void);
void Delay(unsigned long ms);

int main(void) {
    // Kh?i t?o GPIO và ADC
    GPIO_Init();
    ADC_Init();

    while (1) {
        // B?t d?u chuy?n d?i ADC
        ADC1_CR2 |= ADC_CR2_SWSTART;

        // Ch? hoàn t?t chuy?n d?i
        while (!(ADC1_SR & ADC_SR_EOC));

        // Ð?c giá tr? ADC
        unsigned short adc_value = ADC1_DR;

        // Tính di?n áp th?c t? (bù cho t? l? chia di?n áp)
        unsigned long voltage = (adc_value * VREF * VOLTAGE_RATIO) / ADC_RESOLUTION; // mV

        // Tính nhi?t d? (don v? 0,1°C)
        unsigned long temperature = voltage / MV_PER_C; // 0,1°C

        // Ði?u khi?n LED d?a trên nhi?t d?
        if (temperature < TEMP_LOW) {
            GPIOA_BSRR = GPIO_BSRR_BS1 | GPIO_BSRR_BR2;  // PA1 = 1, PA2 = 0
        } else if (temperature > TEMP_HIGH) {
            GPIOA_BSRR = GPIO_BSRR_BR1 | GPIO_BSRR_BS2;  // PA1 = 0, PA2 = 1
        } else {
            GPIOA_BSRR = GPIO_BSRR_BR1 | GPIO_BSRR_BR2;  // PA1 = 0, PA2 = 0
        }

        // Delay d? quan sát
        Delay(100);
    }
}

void GPIO_Init(void) {
    // B?t clock cho GPIOA
    RCC_APB2ENR |= RCC_APB2ENR_IOPAEN;

    // PA0: Analog (LM35) - Không c?n c?u hình mode và config (m?c d?nh là analog)
    GPIOA_CRL &= ~(0xF << 0); // Xóa bit MODE0 và CNF0

    // PA1, PA2: Output Push-Pull, 50 MHz
    GPIOA_CRL &= ~(0xFF << 4); // Xóa bit MODE1, CNF1, MODE2, CNF2
    GPIOA_CRL |= (0x3 << 4) | (0x3 << 8); // MODE1 = 11 (50 MHz), MODE2 = 11 (50 MHz), CNF = 00 (Push-Pull)
}

void ADC_Init(void) {
    // B?t clock cho ADC1
    RCC_APB2ENR |= RCC_APB2ENR_ADC1EN;

    // C?u hình ADCPRE (chia 2 ? ADCCLK = 4 MHz)
    RCC_CFGR &= ~(0x3 << 14);
    RCC_CFGR |= RCC_CFGR_ADCPRE_2;

    // B?t ADC
    ADC1_CR2 |= ADC_CR2_ADON;

    // Hi?u chu?n ADC
    ADC1_CR2 |= ADC_CR2_RSTCAL;
    while (ADC1_CR2 & ADC_CR2_RSTCAL);
    ADC1_CR2 |= ADC_CR2_CAL;
    while (ADC1_CR2 & ADC_CR2_CAL);

    // C?u hình kênh 0 (PA0), th?i gian l?y m?u 55,5 chu k?
    ADC1_SMPR2 |= (0x5 << 0); // SMP0 = 101 (55.5 chu k?)
    ADC1_SQR3 = 0; // Kênh 0

    // B?t chuy?n d?i ph?n m?m
    ADC1_CR2 |= ADC_CR2_EXTSEL; // SWSTART
    ADC1_CR2 |= ADC_CR2_EXTTRIG;
}

void Delay(unsigned long ms) {
    unsigned long i;
    for (i = 0; i < ms * 8000; i++); // U?c lu?ng delay cho 8 MHz
}